{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#digital-logic-design-101","title":"Digital Logic &amp; Design 101","text":"<p>Welcome to DLD-101 \u2014 a concise guide to digital logic, from the basics of gates and Boolean algebra to HDL and FPGA projects.  </p>"},{"location":"#whats-covered","title":"What\u2019s Covered","text":"<ul> <li>Fundamentals: number systems, Boolean algebra, truth tables  </li> <li>Combinational circuits: gates, adders, multiplexers, encoders  </li> <li>Sequential circuits: flip-flops, counters, registers, state machines  </li> <li>HDL (Verilog): syntax, simulation, basic hardware design  </li> <li>Projects: traffic light controller, vending machine FSM, simple ALU  </li> </ul>"},{"location":"#who-this-is-for","title":"Who This Is For","text":"<ul> <li>Students beginning digital logic and design  </li> <li>Hobbyists exploring Verilog and FPGAs  </li> <li>Anyone looking for a practical, structured resource  </li> </ul>"},{"location":"#how-to-use","title":"How To Use","text":"<ol> <li>Navigate through topics using the sidebar.  </li> <li>Work through the examples step by step.  </li> <li>Apply concepts in small projects to solidify understanding.  </li> </ol>"},{"location":"01-intro/boolean-algebra/","title":"Boolean Algebra (a.k.a. Logic Gym)","text":"<p>Boolean algebra is how we reason about 0s and 1s. It\u2019s also your best friend for turning messy logic into elegant circuits.</p>"},{"location":"01-intro/boolean-algebra/#basics","title":"Basics","text":"<ul> <li>AND (\u00b7): 1 if both are 1</li> <li>OR (+): 1 if at least one is 1</li> <li>NOT (\u203e): flips 0 \u2194 1</li> </ul> <p>Truth snippet: <pre><code>A B | A\u00b7B A+B \u00acA\n0 0 |  0   0  1\n0 1 |  0   1  1\n1 0 |  0   1  0\n1 1 |  1   1  0\n</code></pre></p>"},{"location":"01-intro/boolean-algebra/#exercise","title":"Exercise","text":"<ul> <li>Write the truth table for XOR using only A, B, and Boolean ops.</li> </ul>"},{"location":"01-intro/boolean-algebra/#intermediate","title":"Intermediate","text":""},{"location":"01-intro/boolean-algebra/#greatest-hits-laws","title":"Greatest Hits (Laws)","text":"<ul> <li>Identity: A+0=A, A\u00b71=A</li> <li>Null: A+1=1, A\u00b70=0</li> <li>Idempotent: A+A=A, A\u00b7A=A</li> <li>Complement: A+\u00acA=1, A\u00b7\u00acA=0</li> <li>Commutative/Associative/Distributive</li> <li>De Morgan: \u00ac(A\u00b7B)=\u00acA+\u00acB, \u00ac(A+B)=\u00acA\u00b7\u00acB</li> </ul>"},{"location":"01-intro/boolean-algebra/#simplification-example","title":"Simplification Example","text":"<p>Simplify: F=A\u00b7B + A\u00b7\u00acB \u2192 F = A\u00b7(B+\u00acB) = A</p>"},{"location":"01-intro/boolean-algebra/#karnaugh-maps-kmaps","title":"Karnaugh Maps (K\u2011maps)","text":"<ul> <li>Visual method to group 1s and reduce expressions (2\u20134 variables comfortably)</li> </ul>"},{"location":"01-intro/boolean-algebra/#exercise_1","title":"Exercise","text":"<ul> <li>Minimize F(A,B,C)=\u03a3m(1,3,5,7) using a K\u2011map.</li> </ul>"},{"location":"01-intro/boolean-algebra/#advanced","title":"Advanced","text":""},{"location":"01-intro/boolean-algebra/#soppos-forms","title":"SOP/POS Forms","text":"<ul> <li>Sum\u2011of\u2011Products vs Product\u2011of\u2011Sums trade\u2011offs for implementation</li> </ul>"},{"location":"01-intro/boolean-algebra/#dont-cares-x","title":"Don\u2019t Cares (X)","text":"<ul> <li>Treat unused input combos as flexible to further simplify logic</li> </ul>"},{"location":"01-intro/boolean-algebra/#multilevel-logic-and-factoring","title":"Multi\u2011Level Logic and Factoring","text":"<ul> <li>Reduce gate count and depth by factoring expressions</li> </ul>"},{"location":"01-intro/boolean-algebra/#exercise_2","title":"Exercise","text":"<ul> <li>Given F = A\u00b7B + A\u00b7C + B\u00b7C, factor to reduce gate count and sketch a low\u2011depth implementation.</li> </ul>"},{"location":"01-intro/number-systems/","title":"Number Systems (Binary, Decimal, Hex)","text":"<p>Humans vibe with base-10. Computers throw a party in base-2. Hex shows up as the chill mutual friend. Let\u2019s translate between them without breaking a sweat.</p>"},{"location":"01-intro/number-systems/#basics","title":"Basics","text":"<ul> <li>Binary (base-2): digits 0\u20131</li> <li>Decimal (base-10): digits 0\u20139</li> <li>Hex (base-16): digits 0\u20139 + A\u2013F</li> <li>Place value: value = sum(digit \u00d7 base^position)</li> </ul>"},{"location":"01-intro/number-systems/#examples","title":"Examples","text":"<ul> <li>13\u2081\u2080 = 1101\u2082</li> <li>10110\u2082 = 22\u2081\u2080</li> <li>1101\u2082 \u2192 group 4 bits \u2192 D\u2081\u2086</li> </ul>"},{"location":"01-intro/number-systems/#exercises","title":"Exercises","text":"<ul> <li>Convert 45\u2081\u2080 to binary and hex</li> <li>Convert 1001011\u2082 to decimal</li> </ul>"},{"location":"01-intro/number-systems/#intermediate","title":"Intermediate","text":""},{"location":"01-intro/number-systems/#binary-hex-fast-path","title":"Binary \u2194 Hex (fast path)","text":"<ul> <li>Group bits in 4s. 1011\u2082 = B\u2081\u2086. 111001\u2082 = 39\u2081\u2086.</li> </ul>"},{"location":"01-intro/number-systems/#twos-complement-signed-numbers","title":"Two\u2019s Complement (Signed Numbers)","text":"<p>1) Write magnitude in binary  2) Invert bits  3) Add 1 - Example: -5 in 4 bits \u2192 0101 \u2192 1010 \u2192 1011\u2082</p>"},{"location":"01-intro/number-systems/#range","title":"Range","text":"<ul> <li>For n bits: unsigned 0\u20262\u207f-1, signed \u22122\u207f\u207b\u00b9\u20262\u207f\u207b\u00b9\u22121</li> </ul>"},{"location":"01-intro/number-systems/#exercises_1","title":"Exercises","text":"<ul> <li>What\u2019s the 8\u2011bit two\u2019s complement of \u22127?</li> <li>What is the range of a 12\u2011bit signed integer?</li> </ul>"},{"location":"01-intro/number-systems/#advanced","title":"Advanced","text":""},{"location":"01-intro/number-systems/#overflow","title":"Overflow","text":"<ul> <li>Unsigned: carry out from MSB</li> <li>Signed: adding two same\u2011sign numbers yields opposite\u2011sign result</li> </ul>"},{"location":"01-intro/number-systems/#fixedpoint","title":"Fixed\u2011Point","text":"<ul> <li>Represent fractions by fixing a binary point (e.g., Q1.7)</li> </ul>"},{"location":"01-intro/number-systems/#endianness-systems-topic","title":"Endianness (systems topic)","text":"<ul> <li>Byte order in memory: little vs big endian</li> </ul>"},{"location":"01-intro/number-systems/#exercises_2","title":"Exercises","text":"<ul> <li>Detect signed overflow for A + B using MSB and carry logic</li> <li>Represent 0.625 in Q0.8 fixed\u2011point and convert back to decimal</li> </ul> <p>Try small mental chunks: powers of two up to 256 go a long way.</p>"},{"location":"01-intro/what-is-dld/","title":"What is Digital Logic &amp; Design?","text":"<p>Welcome! If computers had a native language, digital logic would be the grammar. We build everything\u2014from adders to CPUs\u2014using simple building blocks that only know two moods: 0 and 1. Moody? Maybe. Powerful? Absolutely.</p>"},{"location":"01-intro/what-is-dld/#basics","title":"Basics","text":"<ul> <li>Digital signals are binary: 0 (low) or 1 (high)</li> <li>Two categories of circuits:</li> <li>Combinational: outputs depend only on current inputs</li> <li>Sequential: outputs depend on inputs + stored state</li> <li>We describe and build hardware with Boolean algebra and HDLs (e.g., Verilog)</li> </ul>"},{"location":"01-intro/what-is-dld/#example","title":"Example","text":"<ul> <li>Light controller: output = ON if motion OR (timer active)</li> <li>That\u2019s simply: <code>Light = Motion + Timer</code></li> </ul>"},{"location":"01-intro/what-is-dld/#exercise","title":"Exercise","text":"<ul> <li>Write a Boolean expression for a door alarm that triggers when (door open AND not disarmed) OR (tamper sensor).</li> </ul>"},{"location":"01-intro/what-is-dld/#intermediate","title":"Intermediate","text":"<ul> <li>Composition: modules connect to form systems (e.g., adder \u2192 ALU \u2192 CPU)</li> <li>Cost metrics: area (gates), delay (critical path), power, and reliability</li> <li>Design flow: spec \u2192 truth table/equations \u2192 simplification \u2192 implementation \u2192 test</li> </ul>"},{"location":"01-intro/what-is-dld/#example_1","title":"Example","text":"<ul> <li>From behavior to logic: \u201codd parity detector\u201d \u2192 XOR all bits \u2192 1 if odd number of 1s</li> </ul>"},{"location":"01-intro/what-is-dld/#exercise_1","title":"Exercise","text":"<ul> <li>List three ways to reduce delay in a combinational path. Hint: balance logic, pipeline, minimize fan-out.</li> </ul>"},{"location":"01-intro/what-is-dld/#advanced","title":"Advanced","text":"<ul> <li>Timing closure: meeting setup/hold times across the whole chip</li> <li>FSMs for control, datapaths for arithmetic; microarchitectural trade-offs</li> <li>HDL to silicon: simulation \u2192 synthesis \u2192 place &amp; route \u2192 timing analysis</li> </ul>"},{"location":"01-intro/what-is-dld/#example_2","title":"Example","text":"<ul> <li>CPU pipeline hazards (control/data) are solved with forwarding, stall, or speculation\u2014implemented with logic and state machines.</li> </ul>"},{"location":"01-intro/what-is-dld/#exercise_2","title":"Exercise","text":"<ul> <li>Sketch a high-level block diagram for a tiny CPU datapath: registers, ALU, MUXes, control FSM.</li> </ul>"},{"location":"01-intro/what-is-dld/#learning-flow","title":"Learning Flow","text":"<ol> <li>Number systems and Boolean algebra</li> <li>Combinational building blocks</li> <li>Sequential circuits and state machines</li> <li>Verilog basics and mini-projects</li> </ol> <p>You bring curiosity; we\u2019ll bring the circuits.</p>"},{"location":"02-combinational/logic-gates/","title":"Logic Gates","text":"<p>Tiny boxes, big impact. Each gate computes a simple Boolean function. Together, they build adders, ALUs, and beyond.</p>"},{"location":"02-combinational/logic-gates/#basics","title":"Basics","text":"<ul> <li>NOT: flips a bit</li> <li>AND / OR: combine inputs by \u201cboth\u201d or \u201ceither\u201d</li> <li>NAND / NOR: AND/OR with a NOT on the output (surprisingly universal!)</li> <li>XOR / XNOR: \u201cdifferent?\u201d vs \u201csame?\u201d</li> </ul>"},{"location":"02-combinational/logic-gates/#truth-tables","title":"Truth Tables","text":"<pre><code>A B | AND OR NAND NOR XOR XNOR\n0 0 |  0   0   1    1   0   1\n0 1 |  0   1   1    0   1   0\n1 0 |  0   1   1    0   1   0\n1 1 |  1   1   0    0   0   1\n</code></pre>"},{"location":"02-combinational/logic-gates/#exercise","title":"Exercise","text":"<ul> <li>Implement XOR using only AND, OR, NOT.</li> </ul>"},{"location":"02-combinational/logic-gates/#intermediate","title":"Intermediate","text":""},{"location":"02-combinational/logic-gates/#universality","title":"Universality","text":"<ul> <li>NAND alone can implement any logic. Same for NOR.</li> <li>If you can express it in AND/OR/NOT, you can realize it with NAND gates.</li> </ul>"},{"location":"02-combinational/logic-gates/#from-gates-to-modules","title":"From Gates to Modules","text":"<ul> <li>Half adder = XOR (sum) + AND (carry)</li> <li>Full adder = 2\u00d7 half adder + OR</li> <li>Ripple-carry adder = chain full adders; delay grows with bit\u2011width</li> </ul>"},{"location":"02-combinational/logic-gates/#exercise_1","title":"Exercise","text":"<ul> <li>Sketch a 1\u2011bit full adder using two half adders and an OR.</li> </ul>"},{"location":"02-combinational/logic-gates/#advanced","title":"Advanced","text":""},{"location":"02-combinational/logic-gates/#gatelevel-realities","title":"Gate\u2011Level Realities","text":"<ul> <li>Fan\u2011out: too many loads slow edges</li> <li>Glitches/hazards: different path delays cause temporary spikes</li> <li>Critical path: longest logic delay limits your clock speed</li> </ul>"},{"location":"02-combinational/logic-gates/#mitigations","title":"Mitigations","text":"<ul> <li>Balance logic depth, buffer high fan\u2011out nets</li> <li>Use synchronous design: register boundaries \u201creset\u201d timing</li> </ul>"},{"location":"02-combinational/logic-gates/#exercise_2","title":"Exercise","text":"<ul> <li>Identify a potential static hazard in <code>F = A\u00b7B + A\u00b7\u00acB + \u00acA\u00b7C</code> and suggest a fix.</li> </ul>"},{"location":"02-combinational/logic-gates/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Prefer minimal logic depth for speed; factor expressions</li> <li>Use XOR wisely\u2014expensive in some libraries vs sum-of-products</li> <li>In FPGAs, LUTs implement small truth tables directly; map your logic to fit LUT inputs</li> </ul>"},{"location":"02-combinational/mux-demux/","title":"Multiplexers (MUX) &amp; Demultiplexers (DEMUX)","text":"<p>Think of a MUX as a traffic cop for bits\u2014selecting which input gets through. A DEMUX does the opposite: one input, many destinations.</p>"},{"location":"02-combinational/mux-demux/#basics","title":"Basics","text":""},{"location":"02-combinational/mux-demux/#mux","title":"MUX","text":"<ul> <li>Inputs: multiple data lines</li> <li>Select: control bits choose the active input</li> <li>Output: the chosen data line</li> </ul> <p>2:1 MUX equation: <pre><code>Y = S'\u00b7D0 + S\u00b7D1\n</code></pre></p>"},{"location":"02-combinational/mux-demux/#demux","title":"DEMUX","text":"<ul> <li>Input: single data line</li> <li>Select: control bits choose the active output</li> <li>Outputs: one line is asserted at a time</li> </ul>"},{"location":"02-combinational/mux-demux/#exercise","title":"Exercise","text":"<ul> <li>Write the truth table for a 2:1 MUX.</li> </ul>"},{"location":"02-combinational/mux-demux/#intermediate","title":"Intermediate","text":""},{"location":"02-combinational/mux-demux/#41-mux-from-21-building-blocks","title":"4:1 MUX from 2:1 building blocks","text":"<ul> <li>Cascade 2:1s and add a second select bit</li> </ul>"},{"location":"02-combinational/mux-demux/#select-encoding","title":"Select Encoding","text":"<ul> <li>For N inputs, need \u2308log2 N\u2309 select lines</li> </ul>"},{"location":"02-combinational/mux-demux/#common-uses","title":"Common Uses","text":"<ul> <li>Choose ALU operands</li> <li>Route bus signals</li> <li>Implement function select (e.g., ALU opcode \u2192 MUX tree)</li> </ul>"},{"location":"02-combinational/mux-demux/#exercise_1","title":"Exercise","text":"<ul> <li>Design a 4:1 MUX with inputs A,B,C,D and selects S1,S0. Write Y in SOP form.</li> </ul>"},{"location":"02-combinational/mux-demux/#advanced","title":"Advanced","text":""},{"location":"02-combinational/mux-demux/#performance-notes","title":"Performance Notes","text":"<ul> <li>Large MUXes as trees (log depth) vs flat (wide) implementations</li> <li>Balance paths to minimize skew and glitches</li> <li>In FPGAs, MUXes map efficiently to LUTs and dedicated MUX primitives</li> </ul>"},{"location":"02-combinational/mux-demux/#demux-design-tips","title":"DEMUX Design Tips","text":"<ul> <li>Ensure only one output is active; use one\u2011hot decoding</li> <li>Combine with enable signals for bus write selection</li> </ul>"},{"location":"02-combinational/mux-demux/#exercise_2","title":"Exercise","text":"<ul> <li>Build an 8:1 MUX using 2:1 cells. What\u2019s the logic depth? How many cells?</li> </ul>"},{"location":"02-combinational/mux-demux/#design-notes","title":"Design Notes","text":"<ul> <li>Prefer hierarchical construction (2:1 \u2192 4:1 \u2192 8:1)</li> <li>Gate\u2011count vs delay trade\u2011offs matter in timing\u2011critical paths</li> </ul>"},{"location":"03-sequential/counters/","title":"Counters","text":"<p>Counters are the \u201codometer\u201d of digital systems. They tick up (or down) every clock and drive timing, indexing, and control.</p>"},{"location":"03-sequential/counters/#basics","title":"Basics","text":"<ul> <li>Up counter: increments each clock</li> <li>Down counter: decrements each clock</li> <li>Modulo\u2011N: wraps after N\u22121 back to 0</li> </ul>"},{"location":"03-sequential/counters/#anatomy-of-an-up-counter","title":"Anatomy of an Up Counter","text":"<ul> <li>Register stores current count</li> <li>Adder computes next = current + 1</li> <li>Reset initializes to 0 (sync or async)</li> </ul>"},{"location":"03-sequential/counters/#exercise","title":"Exercise","text":"<ul> <li>Draw a block diagram for a 4\u2011bit synchronous up counter with synchronous reset.</li> </ul>"},{"location":"03-sequential/counters/#intermediate","title":"Intermediate","text":""},{"location":"03-sequential/counters/#ripple-vs-synchronous","title":"Ripple vs Synchronous","text":"<ul> <li>Ripple (async): each stage toggles the next; simple but accumulates delay</li> <li>Synchronous: all flops share the clock; predictable timing</li> </ul>"},{"location":"03-sequential/counters/#updown-with-enable","title":"Up/Down with Enable","text":"<ul> <li>Add an enable to pause counting; add direction to select +1/\u22121</li> </ul>"},{"location":"03-sequential/counters/#modn-counters","title":"Mod\u2011N Counters","text":"<ul> <li>Compare with N\u22121 and reset to 0, or design with tailored next\u2011state logic</li> </ul>"},{"location":"03-sequential/counters/#exercise_1","title":"Exercise","text":"<ul> <li>Design a mod\u201110 BCD counter: what extra logic is needed?</li> </ul>"},{"location":"03-sequential/counters/#advanced","title":"Advanced","text":""},{"location":"03-sequential/counters/#clock-division","title":"Clock Division","text":"<ul> <li>Use counters to derive slower clocks or strobes (prefer strobes in FPGAs)</li> </ul>"},{"location":"03-sequential/counters/#gray-code-counters","title":"Gray Code Counters","text":"<ul> <li>Only one bit changes per step; great for minimizing glitches across domains</li> </ul>"},{"location":"03-sequential/counters/#performance-tips","title":"Performance Tips","text":"<ul> <li>Keep the carry chain short; split wide counters or pipeline</li> <li>Use vendor primitives for fast adders/counters when available</li> </ul>"},{"location":"03-sequential/counters/#exercise_2","title":"Exercise","text":"<ul> <li>Propose a Gray\u2011code counter for an async FIFO pointer and explain why it\u2019s safer.</li> </ul>"},{"location":"03-sequential/counters/#design-notes","title":"Design Notes","text":"<ul> <li>Prefer synchronous resets; register outputs driving heavy fan\u2011out nets</li> <li>In FPGAs, map counters to dedicated carry chains for best timing</li> </ul>"},{"location":"03-sequential/latches-flipflops/","title":"Latches &amp; Flip-Flops","text":"<p>Memory for bits! Sequential circuits remember state. Latches and flip-flops are the tiny timekeepers that make counters, registers, and CPUs possible.</p>"},{"location":"03-sequential/latches-flipflops/#basics","title":"Basics","text":"<ul> <li>Latch (level-sensitive): follows input while enable is active</li> <li>Flip-Flop (edge-triggered): captures input only on a clock edge (\u2191 or \u2193)</li> <li>D flip-flop: most common; Q \u2190 D on clock edge</li> </ul>"},{"location":"03-sequential/latches-flipflops/#small-builds","title":"Small Builds","text":"<ul> <li>1-bit register = D flip-flop</li> <li>N-bit register = N parallel D flip-flops</li> </ul>"},{"location":"03-sequential/latches-flipflops/#exercise","title":"Exercise","text":"<ul> <li>When would a latch cause unintended transparency?</li> </ul>"},{"location":"03-sequential/latches-flipflops/#intermediate","title":"Intermediate","text":""},{"location":"03-sequential/latches-flipflops/#the-rs-latch-concept","title":"The RS Latch (concept)","text":"<ul> <li>Inputs: S (set), R (reset)</li> <li>Output: Q stores a bit</li> <li>Caveat: avoid S=R=1 in basic SR latch</li> </ul>"},{"location":"03-sequential/latches-flipflops/#d-flip-flop-with-reset","title":"D Flip-Flop with Reset","text":"<ul> <li>Async reset: acts immediately</li> <li>Sync reset: acts on clock edge; preferred for FPGA timing</li> </ul>"},{"location":"03-sequential/latches-flipflops/#setuphold-times","title":"Setup/Hold Times","text":"<ul> <li>Setup: D must be stable before clock edge</li> <li>Hold: D must stay stable after clock edge</li> <li>Violations \u2192 metastability (indeterminate Q for a short time)</li> </ul>"},{"location":"03-sequential/latches-flipflops/#exercise_1","title":"Exercise","text":"<ul> <li>Explain why synchronizers use two flip-flops for asynchronous inputs.</li> </ul>"},{"location":"03-sequential/latches-flipflops/#advanced","title":"Advanced","text":""},{"location":"03-sequential/latches-flipflops/#clocking-strategies","title":"Clocking Strategies","text":"<ul> <li>Single\u2011clock synchronous design is simplest and most robust</li> <li>Clock enables gate updates without creating new clock domains</li> </ul>"},{"location":"03-sequential/latches-flipflops/#cdc-clock-domain-crossing","title":"CDC (Clock Domain Crossing)","text":"<ul> <li>Use 2\u2011FF synchronizers for single\u2011bit signals</li> <li>Use FIFOs or handshakes for multi\u2011bit data</li> </ul>"},{"location":"03-sequential/latches-flipflops/#retiming-pipelining","title":"Retiming &amp; Pipelining","text":"<ul> <li>Move registers to balance path delays and increase clock frequency</li> </ul>"},{"location":"03-sequential/latches-flipflops/#exercise_2","title":"Exercise","text":"<ul> <li>Given a long combinational block, show where to insert a pipeline register to meet a 100 MHz target.</li> </ul>"},{"location":"03-sequential/latches-flipflops/#design-notes","title":"Design Notes","text":"<ul> <li>Register I/Os at boundaries to localize timing</li> <li>Prefer synchronous resets; avoid gated clocks unless using vendor primitives</li> </ul>"},{"location":"04-hdl/intro-to-verilog/","title":"Intro to Verilog (HDL)","text":"<p>Verilog lets you describe hardware like code\u2014but it becomes circuits, not software. Write modules, connect wires, simulate, and then synthesize to real logic.</p>"},{"location":"04-hdl/intro-to-verilog/#basics","title":"Basics","text":""},{"location":"04-hdl/intro-to-verilog/#mental-model","title":"Mental Model","text":"<ul> <li>You\u2019re building hardware structures, not writing sequential programs</li> <li>Many things happen \u201cat once\u201d (concurrency!)</li> <li>Registers (flops) remember; wires combine</li> </ul>"},{"location":"04-hdl/intro-to-verilog/#tiny-taste","title":"Tiny Taste","text":"<pre><code>module and_gate(\n  input  wire a,\n  input  wire b,\n  output wire y\n);\n  assign y = a &amp; b;\nendmodule\n</code></pre>"},{"location":"04-hdl/intro-to-verilog/#exercise","title":"Exercise","text":"<ul> <li>Write a <code>or_gate</code> module using a continuous assignment.</li> </ul>"},{"location":"04-hdl/intro-to-verilog/#intermediate","title":"Intermediate","text":""},{"location":"04-hdl/intro-to-verilog/#sequential-vs-combinational-blocks","title":"Sequential vs Combinational Blocks","text":"<pre><code>// Combinational\nalways @* begin\n  y = (a ^ b) &amp; c; // blocking for comb\nend\n\n// Sequential\nalways @(posedge clk) begin\n  if (rst) q &lt;= 1'b0; // non-blocking for flops\n  else     q &lt;= d;\nend\n</code></pre>"},{"location":"04-hdl/intro-to-verilog/#parameters-generate","title":"Parameters &amp; Generate","text":"<pre><code>module regn #(parameter N=8) (\n  input  wire         clk,\n  input  wire [N-1:0] d,\n  output reg  [N-1:0] q\n);\n  always @(posedge clk) q &lt;= d;\nendmodule\n</code></pre> <pre><code>// Generate an array of adders\nfor (genvar i=0; i&lt;8; i=i+1) begin : add_loop\n  assign sum[i] = a[i] ^ b[i] ^ cin[i];\nend\n</code></pre>"},{"location":"04-hdl/intro-to-verilog/#simple-testbench","title":"Simple Testbench","text":"<pre><code>module tb_and;\n  reg a, b; wire y;\n  and_gate dut(.a(a), .b(b), .y(y));\n  initial begin\n    a=0; b=0; #1; a=0; b=1; #1; a=1; b=0; #1; a=1; b=1; #1;\n  end\nendmodule\n</code></pre>"},{"location":"04-hdl/intro-to-verilog/#exercise_1","title":"Exercise","text":"<ul> <li>Parameterize a 4\u2011bit adder to N bits and simulate with a few vectors.</li> </ul>"},{"location":"04-hdl/intro-to-verilog/#advanced","title":"Advanced","text":""},{"location":"04-hdl/intro-to-verilog/#coding-patterns","title":"Coding Patterns","text":"<ul> <li>One purpose per <code>always</code> block (comb vs seq)</li> <li>Default assignments in comb blocks to avoid latches</li> <li>Register outputs crossing module boundaries</li> </ul>"},{"location":"04-hdl/intro-to-verilog/#fsm-template-onehot","title":"FSM Template (One\u2011Hot)","text":"<pre><code>typedef enum logic [2:0] { S0=3'b001, S1=3'b010, S2=3'b100 } state_t;\nstate_t s, sn;\n\nalways @* begin\n  sn = s; // default\n  unique case (s)\n    S0: sn = start ? S1 : S0;\n    S1: sn = done  ? S2 : S1;\n    S2: sn = S0;\n  endcase\nend\n\nalways @(posedge clk) begin\n  if (rst) s &lt;= S0; else s &lt;= sn;\nend\n</code></pre>"},{"location":"04-hdl/intro-to-verilog/#verification-tips","title":"Verification Tips","text":"<ul> <li>Self\u2011checking tests: compare outputs, <code>$fatal</code> on mismatch</li> <li>Constrain randomize inputs for broader coverage</li> <li>View waveforms with GTKWave</li> </ul>"},{"location":"04-hdl/intro-to-verilog/#exercise_2","title":"Exercise","text":"<ul> <li>Write a self\u2011checking testbench for a 2:1 MUX using randomized inputs and an assertion of <code>y == (s ? d1 : d0)</code>.</li> </ul> <p>Remember: HDL describes structure and timing. If it can\u2019t exist in hardware, it shouldn\u2019t be in your Verilog.</p>"},{"location":"05-projects/","title":"Projects","text":"<p>Apply what you\u2019ve learned with compact, real-world flavored builds. Each project includes a sketch, a truth table or state diagram, and a bite-sized Verilog module.</p>"},{"location":"05-projects/#beginner","title":"Beginner","text":"<ul> <li>Traffic Light Controller (FSM)</li> <li>Inputs: timer tick, pedestrian button</li> <li>Outputs: lights (R/Y/G)</li> <li>Skills: state diagram, synchronous updates</li> <li>Binary Counter with 7\u2011Segment Display</li> <li>Drive common\u2011anode/cathode display, multiplex digits</li> <li>Skills: counters, decoders, timing</li> </ul>"},{"location":"05-projects/#intermediate","title":"Intermediate","text":"<ul> <li>Vending Machine (FSM)</li> <li>Inputs: coin values, select, cancel</li> <li>Outputs: vend, change, display</li> <li>Skills: Mealy/Moore FSMs, modular design</li> <li>Simple ALU</li> <li>Ops: add, sub, AND, OR, XOR, shift</li> <li>Skills: datapath MUXing, opcode decoding</li> </ul>"},{"location":"05-projects/#advanced","title":"Advanced","text":"<ul> <li>UART Tx/Rx</li> <li>Baud generator, framing, oversampling</li> <li>Skills: CDC, timing, verification</li> <li>Tiny CPU (Toy ISA)</li> <li>Register file, ALU, control FSM, instruction memory</li> <li>Skills: microarchitecture, integration, testing</li> </ul>"},{"location":"05-projects/#how-to-approach-projects","title":"How to Approach Projects","text":"<ol> <li>Define I/O and timing behavior</li> <li>Draw block diagram and (if needed) state diagram</li> <li>Build and simulate modules bottom\u2011up</li> <li>Integrate and add self\u2011checking tests</li> </ol> <p>Tip: Keep a log of test vectors and bugs. Future\u2011you will say thanks.</p>"},{"location":"05-projects/#next-steps","title":"Next Steps","text":"<ul> <li>Add a <code>/projects/&lt;name&gt;</code> page for each build with requirements, diagrams, and testbenches</li> <li>Consider a top\u2011level <code>sim/</code> folder for reusable test utilities</li> </ul>"},{"location":"06-resources/","title":"Resources","text":"<p>Curated picks to keep you moving\u2014short, sweet, and actually useful.</p>"},{"location":"06-resources/#reading","title":"Reading","text":"<ul> <li>Digital Design by M. Morris Mano \u2014 classic, clear fundamentals</li> <li>Fundamentals of Digital Logic with Verilog Design by Brown &amp; Vranesic</li> <li>FPGA Prototyping by Verilog Examples by Pong P. Chu</li> </ul>"},{"location":"06-resources/#tools","title":"Tools","text":"<ul> <li>EDA Playground \u2014 quick Verilog simulations in the browser</li> <li>Icarus Verilog + GTKWave \u2014 open-source sim + waveform viewer</li> <li>Quartus / Vivado \u2014 vendor tools for synthesis and FPGA programming</li> </ul>"},{"location":"06-resources/#online-references","title":"Online References","text":"<ul> <li>Verilog LRM summary \u2014 operator precedence and syntax cheat</li> <li>FPGA vendor docs (Intel/Xilinx) \u2014 primitives, block RAMs, DSPs</li> <li>HDLBits (practice problems) \u2014 bite-sized HDL challenges</li> </ul>"},{"location":"06-resources/#cheat-sheets","title":"Cheat Sheets","text":"<ul> <li>Truth tables for common gates</li> <li>K\u2011map patterns (2\u20134 variables)</li> <li>Verilog operators and <code>always</code> templates</li> </ul>"},{"location":"06-resources/#tips","title":"Tips","text":"<ul> <li>Version control your HDL and testbenches early</li> <li>Keep waveforms tidy with named groups and signals</li> <li>Automate sims with simple Makefiles or scripts</li> </ul> <p>Bookmark this page. Add your own go-tos as you discover them.</p>"}]}